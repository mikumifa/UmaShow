// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file game_data.proto (package hakuraku, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2, Struct, Value } from "@bufbuild/protobuf";

/**
 * @generated from enum hakuraku.TargetType
 */
export enum TargetType {
  /**
   * @generated from enum value: TARGET_TYPE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: TARGET_TYPE_SPEED = 1;
   */
  SPEED = 1,

  /**
   * @generated from enum value: TARGET_TYPE_STAMINA = 2;
   */
  STAMINA = 2,

  /**
   * @generated from enum value: TARGET_TYPE_POWER = 3;
   */
  POWER = 3,

  /**
   * @generated from enum value: TARGET_TYPE_GUTS = 4;
   */
  GUTS = 4,

  /**
   * @generated from enum value: TARGET_TYPE_WIZ = 5;
   */
  WIZ = 5,

  /**
   * @generated from enum value: TARGET_TYPE_VITAL = 10;
   */
  VITAL = 10,

  /**
   * @generated from enum value: TARGET_TYPE_SKILL_PTS = 30;
   */
  SKILL_PTS = 30,
}
// Retrieve enum metadata with: proto2.getEnumType(TargetType)
proto2.util.setEnumType(TargetType, "hakuraku.TargetType", [
  { no: 0, name: "TARGET_TYPE_UNKNOWN" },
  { no: 1, name: "TARGET_TYPE_SPEED" },
  { no: 2, name: "TARGET_TYPE_STAMINA" },
  { no: 3, name: "TARGET_TYPE_POWER" },
  { no: 4, name: "TARGET_TYPE_GUTS" },
  { no: 5, name: "TARGET_TYPE_WIZ" },
  { no: 10, name: "TARGET_TYPE_VITAL" },
  { no: 30, name: "TARGET_TYPE_SKILL_PTS" },
]);

/**
 * @generated from message hakuraku.CharStat
 */
export class CharStat extends Message<CharStat> {
  /**
   * @generated from field: optional int32 value = 1;
   */
  value?: number;

  /**
   * @generated from field: optional int32 max = 2;
   */
  max?: number;

  constructor(data?: PartialMessage<CharStat>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.CharStat";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "max", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharStat {
    return new CharStat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharStat {
    return new CharStat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CharStat {
    return new CharStat().fromJsonString(jsonString, options);
  }

  static equals(a: CharStat | PlainMessage<CharStat> | undefined, b: CharStat | PlainMessage<CharStat> | undefined): boolean {
    return proto2.util.equals(CharStat, a, b);
  }
}

/**
 * @generated from message hakuraku.CharStats
 */
export class CharStats extends Message<CharStats> {
  /**
   * @generated from field: optional hakuraku.CharStat speed = 1;
   */
  speed?: CharStat;

  /**
   * @generated from field: optional hakuraku.CharStat stamina = 2;
   */
  stamina?: CharStat;

  /**
   * @generated from field: optional hakuraku.CharStat power = 3;
   */
  power?: CharStat;

  /**
   * @generated from field: optional hakuraku.CharStat wiz = 4;
   */
  wiz?: CharStat;

  /**
   * @generated from field: optional hakuraku.CharStat guts = 5;
   */
  guts?: CharStat;

  /**
   * @generated from field: optional hakuraku.CharStat vital = 6;
   */
  vital?: CharStat;

  /**
   * @generated from field: optional int32 skill_point = 7;
   */
  skillPoint?: number;

  constructor(data?: PartialMessage<CharStats>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.CharStats";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "speed", kind: "message", T: CharStat, opt: true },
    { no: 2, name: "stamina", kind: "message", T: CharStat, opt: true },
    { no: 3, name: "power", kind: "message", T: CharStat, opt: true },
    { no: 4, name: "wiz", kind: "message", T: CharStat, opt: true },
    { no: 5, name: "guts", kind: "message", T: CharStat, opt: true },
    { no: 6, name: "vital", kind: "message", T: CharStat, opt: true },
    { no: 7, name: "skill_point", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharStats {
    return new CharStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharStats {
    return new CharStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CharStats {
    return new CharStats().fromJsonString(jsonString, options);
  }

  static equals(a: CharStats | PlainMessage<CharStats> | undefined, b: CharStats | PlainMessage<CharStats> | undefined): boolean {
    return proto2.util.equals(CharStats, a, b);
  }
}

/**
 * @generated from message hakuraku.GameStats
 */
export class GameStats extends Message<GameStats> {
  /**
   * @generated from field: optional int32 turn = 1;
   */
  turn?: number;

  constructor(data?: PartialMessage<GameStats>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.GameStats";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "turn", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameStats {
    return new GameStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameStats {
    return new GameStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameStats {
    return new GameStats().fromJsonString(jsonString, options);
  }

  static equals(a: GameStats | PlainMessage<GameStats> | undefined, b: GameStats | PlainMessage<GameStats> | undefined): boolean {
    return proto2.util.equals(GameStats, a, b);
  }
}

/**
 * @generated from message hakuraku.CommandParam
 */
export class CommandParam extends Message<CommandParam> {
  /**
   * @generated from field: optional hakuraku.TargetType target_type = 1;
   */
  targetType?: TargetType;

  /**
   * @generated from field: optional int32 value = 2;
   */
  value?: number;

  constructor(data?: PartialMessage<CommandParam>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.CommandParam";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "target_type", kind: "enum", T: proto2.getEnumType(TargetType), opt: true },
    { no: 2, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommandParam {
    return new CommandParam().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommandParam {
    return new CommandParam().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommandParam {
    return new CommandParam().fromJsonString(jsonString, options);
  }

  static equals(a: CommandParam | PlainMessage<CommandParam> | undefined, b: CommandParam | PlainMessage<CommandParam> | undefined): boolean {
    return proto2.util.equals(CommandParam, a, b);
  }
}

/**
 * @generated from message hakuraku.TrainingCommand
 */
export class TrainingCommand extends Message<TrainingCommand> {
  /**
   * @generated from field: optional int32 command_id = 1;
   */
  commandId?: number;

  /**
   * @generated from field: optional int32 command_type = 2;
   */
  commandType?: number;

  /**
   * @generated from field: optional int32 is_enable = 3;
   */
  isEnable?: number;

  /**
   * @generated from field: optional int32 failure_rate = 4;
   */
  failureRate?: number;

  /**
   * @generated from field: optional int32 level = 5;
   */
  level?: number;

  /**
   * @generated from field: repeated int32 training_partners = 6;
   */
  trainingPartners: number[] = [];

  /**
   * @generated from field: repeated int32 tips_partners = 7;
   */
  tipsPartners: number[] = [];

  /**
   * @generated from field: repeated hakuraku.CommandParam params = 8;
   */
  params: CommandParam[] = [];

  constructor(data?: PartialMessage<TrainingCommand>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.TrainingCommand";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "command_id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "command_type", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "is_enable", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "failure_rate", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "level", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "training_partners", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 7, name: "tips_partners", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 8, name: "params", kind: "message", T: CommandParam, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrainingCommand {
    return new TrainingCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrainingCommand {
    return new TrainingCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrainingCommand {
    return new TrainingCommand().fromJsonString(jsonString, options);
  }

  static equals(a: TrainingCommand | PlainMessage<TrainingCommand> | undefined, b: TrainingCommand | PlainMessage<TrainingCommand> | undefined): boolean {
    return proto2.util.equals(TrainingCommand, a, b);
  }
}

/**
 * @generated from message hakuraku.PartnerStat
 */
export class PartnerStat extends Message<PartnerStat> {
  /**
   * @generated from field: optional int32 position = 1;
   */
  position?: number;

  /**
   * @generated from field: optional int32 support_card_id = 2;
   */
  supportCardId?: number;

  /**
   * @generated from field: optional string chara_path = 3;
   */
  charaPath?: string;

  /**
   * @generated from field: optional int32 evaluation = 4;
   */
  evaluation?: number;

  /**
   * @generated from field: optional int32 limit_break = 5;
   */
  limitBreak?: number;

  /**
   * @generated from field: optional int32 exp = 6;
   */
  exp?: number;

  constructor(data?: PartialMessage<PartnerStat>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.PartnerStat";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "position", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "support_card_id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "chara_path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "evaluation", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "limit_break", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "exp", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PartnerStat {
    return new PartnerStat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PartnerStat {
    return new PartnerStat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PartnerStat {
    return new PartnerStat().fromJsonString(jsonString, options);
  }

  static equals(a: PartnerStat | PlainMessage<PartnerStat> | undefined, b: PartnerStat | PlainMessage<PartnerStat> | undefined): boolean {
    return proto2.util.equals(PartnerStat, a, b);
  }
}

/**
 * @generated from message hakuraku.EventOption
 */
export class EventOption extends Message<EventOption> {
  /**
   * @generated from field: optional string desp = 1;
   */
  desp?: string;

  /**
   * @generated from field: optional string detail = 2;
   */
  detail?: string;

  /**
   * @generated from field: optional hakuraku.EventOption.EventOptionType type = 3;
   */
  type?: EventOption_EventOptionType;

  constructor(data?: PartialMessage<EventOption>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.EventOption";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "desp", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "type", kind: "enum", T: proto2.getEnumType(EventOption_EventOptionType), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOption {
    return new EventOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOption {
    return new EventOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOption {
    return new EventOption().fromJsonString(jsonString, options);
  }

  static equals(a: EventOption | PlainMessage<EventOption> | undefined, b: EventOption | PlainMessage<EventOption> | undefined): boolean {
    return proto2.util.equals(EventOption, a, b);
  }
}

/**
 * @generated from enum hakuraku.EventOption.EventOptionType
 */
export enum EventOption_EventOptionType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: CORRECT = 1;
   */
  CORRECT = 1,

  /**
   * @generated from enum value: WRONG = 2;
   */
  WRONG = 2,

  /**
   * @generated from enum value: NEUTRAL = 3;
   */
  NEUTRAL = 3,
}
// Retrieve enum metadata with: proto2.getEnumType(EventOption_EventOptionType)
proto2.util.setEnumType(EventOption_EventOptionType, "hakuraku.EventOption.EventOptionType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CORRECT" },
  { no: 2, name: "WRONG" },
  { no: 3, name: "NEUTRAL" },
]);

/**
 * @generated from message hakuraku.GameEvent
 */
export class GameEvent extends Message<GameEvent> {
  /**
   * @generated from field: optional int32 event_id = 1;
   */
  eventId?: number;

  /**
   * @generated from field: optional string event_name = 2;
   */
  eventName?: string;

  /**
   * @generated from field: repeated hakuraku.EventOption options = 3;
   */
  options: EventOption[] = [];

  constructor(data?: PartialMessage<GameEvent>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.GameEvent";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "event_id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "event_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "options", kind: "message", T: EventOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameEvent {
    return new GameEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameEvent {
    return new GameEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameEvent {
    return new GameEvent().fromJsonString(jsonString, options);
  }

  static equals(a: GameEvent | PlainMessage<GameEvent> | undefined, b: GameEvent | PlainMessage<GameEvent> | undefined): boolean {
    return proto2.util.equals(GameEvent, a, b);
  }
}

/**
 * @generated from message hakuraku.CharInfo
 */
export class CharInfo extends Message<CharInfo> {
  /**
   * @generated from field: repeated hakuraku.PartnerStat partner_stats = 1;
   */
  partnerStats: PartnerStat[] = [];

  /**
   * @generated from field: repeated hakuraku.GameEvent game_events = 2;
   */
  gameEvents: GameEvent[] = [];

  /**
   * @generated from field: optional hakuraku.GameStats game_stats = 3;
   */
  gameStats?: GameStats;

  /**
   * @generated from field: optional hakuraku.CharStats stats = 4;
   */
  stats?: CharStats;

  /**
   * @generated from field: repeated hakuraku.TrainingCommand commands = 5;
   */
  commands: TrainingCommand[] = [];

  constructor(data?: PartialMessage<CharInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.CharInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "partner_stats", kind: "message", T: PartnerStat, repeated: true },
    { no: 2, name: "game_events", kind: "message", T: GameEvent, repeated: true },
    { no: 3, name: "game_stats", kind: "message", T: GameStats, opt: true },
    { no: 4, name: "stats", kind: "message", T: CharStats, opt: true },
    { no: 5, name: "commands", kind: "message", T: TrainingCommand, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharInfo {
    return new CharInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharInfo {
    return new CharInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CharInfo {
    return new CharInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CharInfo | PlainMessage<CharInfo> | undefined, b: CharInfo | PlainMessage<CharInfo> | undefined): boolean {
    return proto2.util.equals(CharInfo, a, b);
  }
}

/**
 * @generated from message hakuraku.RaceMetaInfo
 */
export class RaceMetaInfo extends Message<RaceMetaInfo> {
  /**
   * @generated from field: optional int32 race_instance_id = 1;
   */
  raceInstanceId?: number;

  /**
   * @generated from field: optional int32 season = 2;
   */
  season?: number;

  /**
   * @generated from field: optional int32 weather = 3;
   */
  weather?: number;

  /**
   * @generated from field: optional int32 ground_condition = 4;
   */
  groundCondition?: number;

  /**
   * @generated from field: optional int32 random_seed = 5;
   */
  randomSeed?: number;

  /**
   * @generated from field: optional int32 entry_num = 6;
   */
  entryNum?: number;

  /**
   * @generated from field: optional int32 current_entry_num = 7;
   */
  currentEntryNum?: number;

  /**
   * @generated from field: map<string, google.protobuf.Value> extra = 8;
   */
  extra: { [key: string]: Value } = {};

  constructor(data?: PartialMessage<RaceMetaInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.RaceMetaInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "race_instance_id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "season", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "weather", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "ground_condition", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "random_seed", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "entry_num", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "current_entry_num", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "extra", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RaceMetaInfo {
    return new RaceMetaInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RaceMetaInfo {
    return new RaceMetaInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RaceMetaInfo {
    return new RaceMetaInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RaceMetaInfo | PlainMessage<RaceMetaInfo> | undefined, b: RaceMetaInfo | PlainMessage<RaceMetaInfo> | undefined): boolean {
    return proto2.util.equals(RaceMetaInfo, a, b);
  }
}

/**
 * @generated from message hakuraku.RaceHorseInfo
 */
export class RaceHorseInfo extends Message<RaceHorseInfo> {
  /**
   * @generated from field: optional google.protobuf.Struct payload = 1;
   */
  payload?: Struct;

  constructor(data?: PartialMessage<RaceHorseInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.RaceHorseInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "payload", kind: "message", T: Struct, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RaceHorseInfo {
    return new RaceHorseInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RaceHorseInfo {
    return new RaceHorseInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RaceHorseInfo {
    return new RaceHorseInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RaceHorseInfo | PlainMessage<RaceHorseInfo> | undefined, b: RaceHorseInfo | PlainMessage<RaceHorseInfo> | undefined): boolean {
    return proto2.util.equals(RaceHorseInfo, a, b);
  }
}

/**
 * @generated from message hakuraku.RaceRecord
 */
export class RaceRecord extends Message<RaceRecord> {
  /**
   * @generated from field: optional string filename = 1;
   */
  filename?: string;

  /**
   * @generated from field: optional string full_path = 2;
   */
  fullPath?: string;

  /**
   * @generated from field: optional string created_at = 3;
   */
  createdAt?: string;

  /**
   * @generated from field: optional hakuraku.RaceMetaInfo race_meta_info = 4;
   */
  raceMetaInfo?: RaceMetaInfo;

  /**
   * @generated from field: optional string scenario = 5;
   */
  scenario?: string;

  /**
   * @generated from field: repeated hakuraku.RaceHorseInfo horses = 6;
   */
  horses: RaceHorseInfo[] = [];

  constructor(data?: PartialMessage<RaceRecord>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.RaceRecord";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "full_path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "created_at", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "race_meta_info", kind: "message", T: RaceMetaInfo, opt: true },
    { no: 5, name: "scenario", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "horses", kind: "message", T: RaceHorseInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RaceRecord {
    return new RaceRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RaceRecord {
    return new RaceRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RaceRecord {
    return new RaceRecord().fromJsonString(jsonString, options);
  }

  static equals(a: RaceRecord | PlainMessage<RaceRecord> | undefined, b: RaceRecord | PlainMessage<RaceRecord> | undefined): boolean {
    return proto2.util.equals(RaceRecord, a, b);
  }
}

